/**
 * THIS FILE IS AUTOMATICALLY GENERATED AND MUST NOT BE EDITED MANUALLY!
 *
 * Generator:           0.2.0
 * Yaml Version:        0.1.0
 * Template Version:    0.1.1-32-g825e6f9
 */
/*
 * Copyright (c) 2021, Sensirion AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Sensirion AG nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#define DT_DRV_COMPAT sensirion_sfa30

#include "sfa30.h"

int16_t sfa3x_start_continuous_measurement(const struct i2c_dt_spec *dev_bus)
{
    int16_t error;
    uint8_t buffer[2];
    uint16_t offset = 0;
    offset = sensirion_i2c_add_command_to_buffer(&buffer[0], offset, 0x06);

    error = sensirion_i2c_write_data(dev_bus, &buffer[0], offset);
    if (error)
    {
        return error;
    }
    sensirion_i2c_hal_sleep_usec(1000);
    return NO_ERROR;
}

int16_t sfa3x_stop_measurement(const struct i2c_dt_spec *dev_bus)
{
    int16_t error;
    uint8_t buffer[2];
    uint16_t offset = 0;
    offset = sensirion_i2c_add_command_to_buffer(&buffer[0], offset, 0x104);

    error = sensirion_i2c_write_data(dev_bus, &buffer[0], offset);
    if (error)
    {
        return error;
    }
    sensirion_i2c_hal_sleep_usec(50000);
    return NO_ERROR;
}

int16_t sfa3x_read_measured_values(const struct i2c_dt_spec *dev_bus, int16_t *hcho, int16_t *humidity,
                                   int16_t *temperature)
{
    int16_t error;
    uint8_t buffer[9];
    uint16_t offset = 0;
    offset = sensirion_i2c_add_command_to_buffer(&buffer[0], offset, 0x327);

    error = sensirion_i2c_write_data(dev_bus, &buffer[0], offset);
    if (error)
    {
        return error;
    }

    sensirion_i2c_hal_sleep_usec(5000);

    error = sensirion_i2c_read_data_inplace(dev_bus, &buffer[0], 6);
    if (error)
    {
        return error;
    }
    *hcho = sensirion_common_bytes_to_int16_t(&buffer[0]);
    *humidity = sensirion_common_bytes_to_int16_t(&buffer[2]);
    *temperature = sensirion_common_bytes_to_int16_t(&buffer[4]);
    return NO_ERROR;
}

int16_t sfa3x_get_device_marking(const struct i2c_dt_spec *dev_bus, uint8_t *device_marking,
                                 uint8_t device_marking_size)
{
    int16_t error;
    uint8_t buffer[48];
    uint16_t offset = 0;
    offset = sensirion_i2c_add_command_to_buffer(&buffer[0], offset, 0xD060);

    error = sensirion_i2c_write_data(dev_bus, &buffer[0], offset);
    if (error)
    {
        return error;
    }

    sensirion_i2c_hal_sleep_usec(2000);

    error = sensirion_i2c_read_data_inplace(dev_bus, &buffer[0], 32);
    if (error)
    {
        return error;
    }
    sensirion_common_copy_bytes(&buffer[0], device_marking,
                                device_marking_size);
    return NO_ERROR;
}

int16_t sfa3x_device_reset(const struct i2c_dt_spec *dev_bus)
{
    int16_t error;
    uint8_t buffer[2];
    uint16_t offset = 0;
    offset = sensirion_i2c_add_command_to_buffer(&buffer[0], offset, 0xD304);

    error = sensirion_i2c_write_data(dev_bus, &buffer[0], offset);
    if (error)
    {
        return error;
    }
    sensirion_i2c_hal_sleep_usec(100000);
    return NO_ERROR;
}

static int sfa30_sample_fetch(const struct device *dev, enum sensor_channel chan)
{

    struct sfa30_data *data = dev->data;
    const struct sfa30_config *cfg = dev->config;

    int16_t error = sfa3x_read_measured_values(&cfg->bus, &data->hcho, &data->humidity, &data->temperature);

    if (error != 0)
    {
        printk("Error while reading sfa30 values %i\n", error);
    }

    return error;
}

static int sfa30_channel_get(const struct device *dev,
                             enum sensor_channel chan,
                             struct sensor_value *val)
{

    const struct sfa30_data *data = dev->data;

    if (chan == SENSOR_CHAN_AMBIENT_TEMP)
    {

        sensor_value_from_float(val, data->temperature / 200.0f);
    }

    if (chan == SENSOR_CHAN_HUMIDITY)
    {
        sensor_value_from_float(val, data->humidity / 100.0f);
    }

    if (chan == SENSOR_CHAN_HCO)
    {
        sensor_value_from_float(val, data->hcho / 5.0f);
    }

    return 0;
}

#if defined(CONFIG_PM_DEVICE)
static int sfa30_pm_action(const struct device *dev,
                           enum pm_device_action action)
{

    return -ENOTSUP;
}
#endif /* CONFIG_PM_DEVICE */

static int sfa30_init(const struct device *dev)
{
    const struct sfa30_config *cfg = dev->config;
    int16_t error = sfa3x_device_reset(&cfg->bus);
    if (error)
    {
        printk("Error resetting device: %i\n", error);
        return -1;
    }

    uint8_t device_marking[42];
    error = sfa3x_get_device_marking(&cfg->bus, &device_marking[0], sizeof(device_marking));
    if (error)
    {
        printk("Error getting device marking: %i\n", error);
        return -1;
    }
    printk("Device marking: %s\n", device_marking);

    error = sfa3x_start_continuous_measurement(&cfg->bus);

    k_sleep(K_MSEC(500));
    return error;
}

static const struct sensor_driver_api sfa30_api = {
    .sample_fetch = sfa30_sample_fetch,
    .channel_get = sfa30_channel_get,
};

#define SFA30_INIT(n)                                     \
    static struct sfa30_data sfa30_data_##n;              \
                                                          \
    static const struct sfa30_config sfa30_config_##n = { \
        .bus = I2C_DT_SPEC_INST_GET(n),                   \
        .model = DT_INST_ENUM_IDX(n, model)};             \
                                                          \
    PM_DEVICE_DT_INST_DEFINE(n, sfa30_pm_action);         \
                                                          \
    DEVICE_DT_INST_DEFINE(n,                              \
                          sfa30_init,                     \
                          NULL,                           \
                          &sfa30_data_##n,                \
                          &sfa30_config_##n,              \
                          POST_KERNEL,                    \
                          CONFIG_SENSOR_INIT_PRIORITY,    \
                          &sfa30_api);

DT_INST_FOREACH_STATUS_OKAY(SFA30_INIT)